---
title: "hw2_zheng"
author: "Charles Zheng"
date: "07/24/2015"
output: pdf_document
---

# Problem 1

```{r}
edat0 <- read.csv("PrezElection2012.csv", sep = ",")
sapply(edat0, class)
filt <- !(edat0$State %in% c("AK", "HI", "DC") | edat0$FIPS == 0)
edat <- edat0[filt, ]
rownames(edat) <- paste0("FIPS", edat$FIPS)

dim(edat) # 3108 6
length(unique(edat$State)) # 48
setdiff(unique(edat0$State), unique(edat$State)) # AK DC HI
names(edat)
```

# Problem 2

```{r}
library(maptools)
library(RColorBrewer)
library(classInt)

shapes <- readShapeSpatial("UScounties/UScounties.shp")
class(shapes)
class(shapes)

sapply(shapes@data, class)
sfips <- as.numeric(as.character(shapes@data$FIPS))
rownames(shapes@data) <- paste0("FIPS", sfips)
length(shapes@polygons)
shapes@polygons[[1]]
```

Joining edat and shapes

```{r}
dim(edat)
length(unique(edat$FIPS)) #3108
length(unique(shapes@data$FIPS)) #3141
length(unique(intersect(edat$FIPS, sfips))) #3108
```

The shapes data contains all the counties we need.
Now we make the spatial polygons data frame.

```{r}
edat2 <- edat[rownames(edat) %in% rownames(shapes@data), ]
shapes2 <- shapes[rownames(shapes@data) %in% rownames(edat), ]
rownames(shapes2@data) <- rownames(shapes@data)[rownames(shapes@data) %in% rownames(edat)]
for (i in 1:length(shapes2)) {
  shapes2@polygons[[i]]@ID <- rownames(shapes2@data)[i]
}
edat3 <- SpatialPolygonsDataFrame(shapes2, edat2)
names(edat3)
pal <- brewer.pal(5, "Blues")
q5 <- classIntervals(edat3@data$Obama, n = 5, style = "quantile")
q5colors <- findColours(q5, pal)
plot(edat3, col = q5colors)
```

# Problem 3


```{r}
library(spdep)
adj <- read.table("county_adjacency.txt", sep = "", header = FALSE, fill = TRUE)
filler_inds <- which(!is.na(adj[, 4]))
filled_inds <- cumsum(!is.na(adj[, 4]))
adj[, 3:4] <- adj[filler_inds[filled_inds], 3:4]
## Found an misentered row
adj[9629, 1:2] <- adj[9629, 2:1]
adj[, 2] <- as.numeric(as.character(adj[, 2]))
adj[, 4] <- as.numeric(as.character(adj[, 4]))
```

Forming the nb object

```{r}
temp0 <- c(as.character(adj[, 2]), as.character(adj[, 4]))
afips <- sort(unique(as.numeric(temp0)))
## Define the mapping from integers to FIPS
efips <- sort(unique(edat$FIPS))
fips2int <- numeric(max(efips))
fips2int[efips] <- 1:length(efips)
enames <- paste0("FIPS", efips)
names(fips2int)[efips] <- enames
length(afips) # 3234
length(unique(edat$FIPS)) # 3108
length(intersect(unique(edat$FIPS), afips)) # 3108
## Filter out guys in adj
filt <- (adj[, 2] %in% efips) & (adj[, 4] %in% efips) & (adj[, 2] != adj[, 4])
adjf <- adj[filt, ]
dim(adjf) # 21139 4

## Symmetrize neighbor list
adjfs <- adjf; names(adjfs) <- names(adjf)[c(3, 4, 1, 2)]
adj2 <- rbind(adjf, adjfs)
dim(adj2)
length(unique(adj2[, 2])) # 3107
sort(setdiff(efips, unique(adj2[, 2]))) # 51510
fips2int[51510] # 2881
nb0 <- tapply(fips2int[adj2[, 4]], enames[fips2int[adj2[, 2]]], c)
length(nb0) # 3107
nb0 <- sapply(nb0, unique)
## These counties only had neighbors outside the census
empties <- fips2int[setdiff(enames, names(nb0))]
length(empties) # 1
nb1 <- as.list(numeric(3108))
nb1[fips2int[names(nb0)]] <- nb0
nb1[[2881]] <- 2881
nb1 <- sapply(nb1, sort)
nb1 <- sapply(nb1, as.integer)
nb2 <- structure(nb1, class = "nb", region.id = enames,
                 GeoDa = list(shpfile = "unknown", ind = "unknown"),
                 gal = TRUE, call = TRUE, sym = TRUE)
```

Converting NB to listw.
We have to manually handle row 2881 since it has no neighbors.

```{r}
lw <- nb2listw(nb2)
lw$weights[[2881]] <- 0
```

# Problem 4

```{r}
res1 <- spautolm(Obama ~ 1, data = edat, listw=lw)
summary(res1)
```

Code for plotting

```{r}
edat2 <- edat
edat2["fitted1"] <- res1$fit$fitted.values
edat2["resid1"] <- res1$fit$residuals

plot_edat <- function(edat, variable, colr = "Blues") {
  edat3 <- SpatialPolygonsDataFrame(shapes2, edat)
  pal <- brewer.pal(5, colr)
  q5 <- classIntervals(edat3@data[, variable], n = 5, style = "quantile")
  q5colors <- findColours(q5, pal)
  plot(edat3, col = q5colors)
}

plot_edat(edat2, "fitted1")
plot_edat(edat2, "resid1", "Reds")
```

# Problem 5

```{r}
census_dat <- read.table("census/DataSet.txt", header = TRUE, sep = ",")
census_dict <- read.fwf("census/DataDict.txt", header = FALSE, 
                        widths=c(10, 87, 5, 7, 12, 8, 9, 8))
census_dat$fips <- as.numeric(as.character(census_dat$fips))

## Choose some variables that make sense
census_dat2 <- with(census_dat, 
                    data.frame(FIPS = fips, pop = PST045214,
                               age18 = AGE295213, age65 = AGE775213,
                               sex = SEX255213, white = RHI125213 ,
                               black = RHI225213, hisp = RHI725213, 
                               college = EDU685213, homes = HSG445213,
                               density =  POP060210))

length(unique(census_dat2$FIPS)) # 3195
length(unique(intersect(census_dat2$FIPS, efips))) # 3108
edat2 <- merge(edat, census_dat2, by = "FIPS")
rownames(edat2) <- paste0("FIPS", edat2$FIPS)

## Divide Obaama by Number of votes

edat2["Obama_Rate"] <- edat2$Obama/edat2$TotalVotes
```

# Problem 6

```{r}
res2 <- spautolm(Obama_Rate ~ log(pop + 1) + age18 + age65 + sex + black + hisp + density,
                 data = edat2, listw=lw)
summary(res2)
```

```{r}
edat2["fitted2"] <- res2$fit$fitted.values
edat2["resid2"] <- res2$fit$residuals
plot_edat(edat2, "fitted2")
plot_edat(edat2, "resid2", "Reds")
```

Compared with the residuals in problem 4, the residuals of the new model are much less spatially correlated.
