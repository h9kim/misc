---
title: "Simulating (Almost) Linear Models"
author: "Charles Zheng"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

## Introduction

Linear model:

$$
y = x_A '\beta + \epsilon
$$
where $x_A$ are active variables,

$$
x_I = x_A' \Gamma + E
$$

where $x_B$ are inactive variables.


Almost-linear model:

$$
y = x_A' \beta_A +\delta f(x_A) + \epsilon
$$

while as before,

$$
x_I = x_A' \Gamma + E
$$

where $f(x_A)$ is a nonlinear perturbation satisfying $\text{E}[f(x_A) x_A] = 0$

In both the linear and almost-linear model, if we define
$$
\beta = \text{E}[x x']^{-1} \text{E}[y x]
$$
then
$$\beta_I = 0$$
and
$$\beta_A = \beta_A$$

### Examples of nonlinear functions

Nadaraya-Watson surface:

Let $u_1, .., u_k$ be control points in the space of active variables $\mathcal{X}_A$,
let $\alpha_1,...,\alpha_k$ be real-valued amplitudes and
let $w_1,..., w_k$ be weights, and $\phi(x)$ the standard multivariate normal density
Then define
$$
\tilde{f}(x) = \frac{\sum_{i=1}^k w_i \alpha_i \phi(x - u_i)}{\sum_{i=1}^k w_i \phi(x - u_i)}
$$
and
$$
f(x) = \tilde{f}(x) - \gamma'x 
$$
where $\gamma$ is defined by
$$
\gamma = \text{E}[x x']^{-1} \text{E}[\tilde{f}(x) x]
$$

### Code

The following assumes that $x \sim N(0, I)$.

```{r}
library(reginference)

randn <- function(n, p = n) {
  matrix(rnorm(n * p), n, p)
}

randu <- function(n, p = n, center = FALSE) {  
  ans <- matrix(runif(n * p), n, p)
  if (center) ans <- 2 * (ans - .5)
  ans
}


nw_surface <- function(x, u, a, w, handle = TRUE, normalize = TRUE) {
  x <- as.matrix(x)
  if (!normalize) {
    f <- function(x) {
      if (is.null(dim(x))) x <- t(x)
      x <- as.matrix(x)
      dm <- fastPdist2(x, u)
      dm2 <- exp(-(dm^2)/2)
      dm3 <- t(t(dm2) * w)
      rs <- rowSums(dm3)
      dm4 <- dm3/rs
      as.vector(dm4 %*% a)
    }
    if (handle) {
      return (f)

    } else {
      return (f(x))
    }
  }
  f0 <- nw_surface(x, u, a, w, TRUE, FALSE)
  y0 <- f0(x)
  n <- dim(x)[1]
  res <- lm(y0 ~ x)
  gm <- res$coefficients[-1]
  yadj <- y0 - res$fitted + res$coefficients[1]
  cc <- mean(yadj)
  nm <- sqrt(sum((yadj - cc)^2)/n)
  f <- function(x) {
    (f0(x) - as.vector(x %*% gm) - cc)/nm
  }
  if (handle) return (f)
  ynew <- (yadj - cc)/nm
  ynew
}

random_nw_surface <- function(x, k, handle = TRUE, normalize = TRUE) {
  x <- as.matrix(x)
  n <- dim(x)[1]
  u <- x[sample(n, k), ]
  w <- rep(1, k)
  a <- rnorm(k)
  nw_surface(x, u, a, w, handle, normalize)
}


x <- randn(100, 2)
u <- randn(3, 2)
w <- rep(1, 3)
a <- rnorm(3)
f <- nw_surface(x, u, a, w)
y <- f(x)
lm(y ~ x)
x2 <- randu(1000, 2, TRUE)
y2 <- f(x2)
library(rgl)
plot3d(cbind(x2, y2))
f2 <- random_nw_surface(x, 10)
lm(f2(x) ~ x)
mean(f2(x))
library(magrittr)
(z <- cbind(x2, random_nw_surface(x2, 20, FALSE))) %>% plot3d()

```